---
title: 資料庫選型
description: 探索不同資料庫類型，如 SQL 與 NoSQL，及其使用案例與選擇標準。
icon: Database
---

## 資料庫不只有 Relational Database！

上學期很多人應該都有修過資料庫，但我們僅停留在 Relational Database...

但其實還有超多類型的資料庫，分別負責各種資訊系統開發場景！

* **關聯式 (SQL)**：PostgreSQL、MySQL、MariaDB、Oracle、SQL Server
* **文件型 (Document)**：MongoDB、CouchDB、RavenDB
* **鍵值型 (Key-Value)**：Redis、Memcached、DynamoDB
* **列式 (Column-Family)**：Cassandra、HBase、ScyllaDB
* **圖形 (Graph)**：Neo4j、ArangoDB、JanusGraph
* **時序 (Time-Series)**：InfluxDB、TimescaleDB、Prometheus
* **搜尋引擎 (Search)**：Elasticsearch、Solr、Meilisearch

> **小提示**：想像一下，如果你要蓋房子，不會只有一種槌子可以用。針對不同的任務（釘釘子、鎖螺絲、砌磚），你會需要不同的工具。資料庫也是一樣的道理！

<Callout type="info">
### 資料庫種類繁多
除了大家熟悉的關聯式資料庫 (SQL)，還有文件型、鍵值型、列式、圖形、時序、搜尋引擎等多種 NoSQL 資料庫，每種類型都有其特定的應用場景和優勢。
</Callout>

## 資料庫是系統設計中最主要的一環

在軟體工程師的職涯中，系統設計面試是常見的挑戰。

深入理解不同類型資料庫的特性和應用場景，不僅能幫助你在面試中脫穎而出，更能為你提供構建可擴展、高效能系統的關鍵知識。

選擇合適的資料庫架構，往往是決定系統成敗的重要因素。

例如：設計一個 TikTok 這樣的影音社交平台，需要同時運用：
- **關聯式資料庫**：用戶資料（帳號、密碼、信箱）、用戶之間的關注關係、影片權限設定。這些資料結構固定，且需要高度一致性。
- **文件型資料庫**：影片的動態內容（標題、描述、音樂）、用戶評論、按讚等互動記錄。這些內容結構多變，且寫入頻繁。
- **搜尋引擎**：影片標題、描述、標籤的全文檢索，讓用戶能快速找到想看的影片。
- **快取系統 (通常是鍵值型)**：熱門影片、推薦列表的即時存取，減少對主要資料庫的壓力，提升反應速度。

> 所以資料庫遠比你想像的還要複雜！選擇對的組合，才能讓系統飛起來！

<Callout type="info">
### 資料庫選型的核心地位
在系統設計中，選擇合適的資料庫是至關重要的決策。它直接影響系統的效能、可擴展性、開發複雜度和成本。一個複雜的應用（如 TikTok）通常會組合使用多種類型的資料庫。
</Callout>

## 為什麼資料庫選型重要？

資料庫會影響各種資源的運用與效能，例如：

* **資料怎麼存**：怎麼使用越少的資源存取越多的資料？（就像整理房間，好的收納方式可以省空間）
* **跑得快不快**：怎麼存取決定回應速度與可擴展性？（就像圖書館的索引，好的索引讓你秒找到書）
* **好不好開發**：是否有開發體驗與複雜度？（有些工具用起來順手，有些則很卡）
* **花錢多不多**：還要考慮學習、維運與雲端成本...（買工具、請人維護、租場地都要錢）
* **未來好不好改**：因為資料量通常龐大，遷移代價通常極高...（搬家很累，搬大量的資料更累！）

> **重點**：沒有「最好」，只有「最適合」你需求的資料庫。就像挑選交通工具，去巷口買飲料可能騎腳踏車最方便，環島可能開車或搭火車比較適合。

<Callout type="info">
### 選型關鍵：適合才重要
資料庫的選擇會深刻影響資料儲存效率、系統回應速度、開發體驗、維運成本以及未來的可維護性。記住，沒有萬能的資料庫，只有最適合當前需求的選擇。
</Callout>

## SQL vs NoSQL：兩大陣營

| **特性**        | **SQL (關聯式)**                                                                                                                               | **NoSQL (非關聯式)**                                                                                                                               |
| --------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| 資料結構        | Schema‑on‑Write (寫入前定義好結構，像填格字本，每個格子寫什麼都規定好了)                                                                             | Schema‑on‑Read / Flexible (讀取時才解析結構，像筆記本，可以隨意塗鴉、貼東西)                                                                                 |
| 一致性模型      | ACID 強一致 (交易過程中，資料要嘛全部成功，要嘛全部失敗，非常嚴謹)                                                                                      | BASE 最終一致 (系統暫時可能有點小不一致，但最終會同步好，比較有彈性)                                                                                          |
| 優勢            | 複雜查詢、交易可靠、資料完整性高                                                                                                                            | 高擴展性 (容易增加更多機器來分攤負載)、讀寫彈性、特定場景效能極佳                                                                                                  |
| 常見應用        | 銀行系統 (每一筆交易都不能出錯)、訂單管理 (庫存、訂單狀態要準確)、學校選課系統 (學生、課程、成績之間的關係明確)                                                              | 內容管理系統 (CMS，像部落格文章)、快取 (暫存常用資料加速讀取)、大數據分析 (處理海量且多樣的資料)、社群媒體動態 (訊息、貼文變化快速)                                                 |

> Schema-on-Write：寫入時定義結構，確保資料一致性。
> Schema-on-Read：讀取時才解析結構，提供彈性。

<Callout type="info">
### SQL vs NoSQL 核心差異
- **SQL (關聯式)**：強調 Schema-on-Write (結構化資料) 和 ACID 強一致性，適合複雜查詢和交易可靠性高的場景，如銀行、訂單系統。
- **NoSQL (非關聯式)**：提供 Schema-on-Read (彈性結構) 和 BASE 最終一致性，優勢在於高擴展性、讀寫彈性和特定場景的高效能，如內容管理、快取、大數據。
</Callout>

## 思考

如果你要設計一個社群媒體 App...

1.  **Threads Post (類似推特的短貼文)?**
    *   **可能會選擇**：關聯式資料庫 (如 PostgreSQL, MySQL) 儲存核心用戶資料、貼文內容、關係 (誰追蹤誰、誰喜歡哪篇貼文)。因為貼文結構相對固定，用戶關係查詢頻繁。也可能搭配文件型資料庫或搜尋引擎處理貼文的標籤、搜尋等。
    *   **思考點**：需要快速讀取特定用戶的貼文時間軸，貼文間的轉發、回覆關係也需要處理。

2.  **Instagram Story (限時動態)?**
    *   **可能會選擇**：NoSQL 資料庫，特別是鍵值型 (如 Redis, DynamoDB) 或文件型 (如 MongoDB)。因為限時動態生命週期短 (24小時)，讀寫頻繁，對一致性要求可能稍低於一般貼文，但對可用性和速度要求極高。
    *   **思考點**：如何快速寫入大量的圖片/影片？如何快速讀取好友的限時動態？過期後如何有效清除？

> 你會選擇哪一種資料庫？這沒有標準答案，通常是多種資料庫的組合！

### SQL (關聯式資料庫)

*   **核心概念**：表格 (Table) + 關聯 (Relation)。想像成 Excel 試算表，每個表有固定的欄位，表跟表之間可以有關聯。
    *   **範例：學生選課系統**
        *   `學生表 (Students)`：學號 (主鍵), 姓名, 科系
        *   `課程表 (Courses)`：課程編號 (主鍵), 課程名稱, 學分
        *   `選課記錄表 (Enrollments)`：選課流水號 (主鍵), 學號 (外鍵, 連到學生表), 課程編號 (外鍵, 連到課程表), 成績
        *   透過這些關聯，我們可以輕易查詢「某個學生修了哪些課」或「某門課有哪些學生選修」。
*   **ACID 保證** (確保交易的可靠性，就像銀行轉帳一樣，要嘛成功錢轉過去，要嘛失敗錢還在原地)
    *   **A**tomicity (原子性)：交易中的所有操作，要麼全部完成，要麼全部不完成。不會只做一半。
    *   **C**onsistency (一致性)：交易完成後，資料庫從一個一致的狀態轉到另一個一致的狀態。例如，轉帳後，A帳戶減少的金額等於B帳戶增加的金額。
    *   **I**solation (隔離性)：多個交易同時進行時，彼此之間不會互相干擾。就像每個人在獨立的房間操作，不會看到別人改到一半的資料。
    *   **D**urability (持久性)：一旦交易完成，其結果就是永久性的，即使系統故障也不會遺失。
*   **強項**：需要強一致 & 複雜關聯 (銀行、ERP、訂單系統)。
*   **代表**：PostgreSQL、MySQL、Oracle、SQL Server

> 相信大家都老熟了... 但別忘了，關聯式資料庫依然是許多系統的核心！

### NoSQL (非關聯式資料庫)

*   **核心**：Not Only SQL，多樣資料模型。提供 SQL 以外的資料儲存方式。
*   **BASE 模型** (最終一致，相對於 ACID 的另一種選擇，更強調可用性)
    *   **B**asically **A**vailable (基本可用)：系統在任何時候都能回應請求，即使部分節點故障。
    *   **S**oft State (軟狀態)：系統狀態可以隨時間改變，即使沒有新的輸入。
    *   **E**ventually **C**onsistent (最終一致性)：如果沒有新的更新，系統中的所有資料副本最終會達到一致的狀態。
*   **優勢**：高擴展 (容易橫向擴展，加機器就好)、彈性 (資料格式不用先訂死)、特定場景高效能。
*   **代表類型**：Key‑Value、Document、Column‑Family、Graph

> 你會發現 NoSQL 的資料庫更能拓展系統的規模，但相對的也會犧牲掉一些穩定性或一致性的保證。

## NoSQL 四大類型概覽

1.  **Key‑Value Stores**
2.  **Document Stores**
3.  **Column‑Family Stores**
4.  **Graph Databases**

### 1️⃣ Key‑Value Stores（KV）

*   就是一個 Key (唯一的識別字) 對應一個 Value (值)，有點像 JSON、Map、Object 一樣，非常簡單。
    *   **範例：使用者 Session 快取**
        *   `Key`: "session:user123_abcdef" (Session ID)
        *   `Value`: `{"userId": "user123", "username": "student_A", "loginTime": "2023-10-26T10:00:00Z"}` (使用者資訊)
    *   **範例：API 限流 (Rate Limiting)**
        *   `Key`: "rate_limit:user_ip:192.168.1.100:api_endpoint_X"
        *   `Value`: `15` (表示該 IP 在此 API 端點的1分鐘內已請求15次)
        *   當請求進來時，檢查對應 Key 的 Value。如果超過限制 (例如 20 次)，就拒絕請求。
*   `Key → Value` 直接映射，操作極速 (因為不用做複雜的查詢或關聯)。
*   典型場景：**快取** (網頁快取、資料庫查詢結果快取)、**Session 管理** (記錄使用者登入狀態)。
*   代表：Redis、DynamoDB、Memcached

### 2️⃣ Document Stores

*   就是 JSON/BSON 文件，Schema‑Flexible (每個文件可以有不同的欄位，像寫筆記一樣自由)。
    *   **範例：部落格文章系統**
        *   一篇文章可以是一個 Document：
            ```json
            {
              "_id": "post123",
              "title": "我的第一篇部落格",
              "author_id": "user789",
              "content": "這是一篇關於...",
              "tags": ["生活", "程式"],
              "publish_date": "2023-10-26",
              "comments": [
                { "user_id": "userABC", "comment_text": "寫得太好了！", "timestamp": "2023-10-27T09:00:00Z" },
                { "user_id": "userXYZ", "comment_text": "期待下一篇！", "timestamp": "2023-10-27T10:30:00Z" }
              ],
              "likes": 150
            }
            ```
        *   另一篇文章可能多了 `cover_image_url` 欄位，或少了 `likes`。
*   典型場景：CMS (內容管理系統)、logs (系統日誌)、使用者設定檔。
*   代表：MongoDB、CouchDB、Firebase

> JSON 是純文字格式，而 BSON 是二進制格式，提供更高效的序列化與更多資料類型支援。MongoDB 就是用 BSON。

其實很多應用程式，都有一個叫 Store 的東西，用來存一些簡單的資訊，例如使用者設定，就很適合用 Document Store。

### 3️⃣ Column‑Family Stores

*   Row Key + Column Families，寫入吞吐高。想像成一個超大的表格，但它是按「列家族 (Column Family)」來組織的，每個家族可以包含多個欄位。讀取特定家族的資料會很快。
    *   **範例：使用者行為追蹤**
        *   Row Key: `user_id_ABC`
        *   Column Family `profile_info`:
            *   `name: "Alice"`
            *   `email: "alice@example.com"`
        *   Column Family `activity_logs`: (時間戳是欄位名的一部分)
            *   `login_timestamp_20231026100000: "192.168.1.5"`
            *   `page_view_timestamp_20231026100100: "/products/item123"`
            *   `purchase_timestamp_20231026100500: "order_id_XYZ"`
*   典型場景：大數據分析 (如 Hadoop 生態系)、時間序列資料 (如感測器數據)、需要高寫入量的應用。
*   代表：Cassandra、HBase、Bigtable

> 把資料分類存放 (在不同的 Column Family)，查詢複雜度就會降低、更有效率！適合欄位非常多，但每次查詢只關心其中一部分欄位的場景。

### 4️⃣ Graph Databases

*   Nodes (節點) + Edges (邊) 表示關係，遍歷高效。非常適合用來表示物件之間的複雜關係。
    *   **範例：社交網路**
        *   Nodes: `User A`, `User B`, `Post P1`, `Group G1`
        *   Edges:
            *   `User A` -[:FRIENDS_WITH]-> `User B`
            *   `User A` -[:POSTED]-> `Post P1`
            *   `User B` -[:LIKED]-> `Post P1`
            *   `User A` -[:MEMBER_OF]-> `Group G1`
    *   查詢「User A 的朋友的朋友喜歡了哪些貼文？」會非常直觀且高效。
*   典型場景：社交網路 (好友關係、推薦)、推薦引擎 (商品推薦、內容推薦)、詐欺偵測 (分析不尋常的關聯模式)。
*   代表：Neo4j、Amazon Neptune

### 5️⃣ Vector Databases (近年來非常火紅！)

*   專門處理向量資料 (Embedding)。向量可以理解為將文字、圖片、聲音等轉換成一串數字，這串數字代表了該物件在某個高維空間中的位置。
    *   **為什麼需要？** AI 模型（尤其是大型語言模型 LLM）常常把輸入轉換成向量來理解和比較。
    *   **範例：語意搜尋**
        *   傳統關鍵字搜尋："便宜 蘋果 手機" -> 只會找包含這三個詞的。
        *   向量搜尋：使用者輸入 "CP值高的水果牌手機"，系統將其轉為向量，然後在資料庫中尋找「語意上最接近」的向量（可能對應到 iPhone SE 或其他平價 iPhone）。
*   典型場景：推薦系統 (找到相似的用戶/商品)、圖像搜尋 (以圖搜圖)、自然語言處理 (語意搜尋、問答系統)、**AI 應用**、**RAG (Retrieval Augmented Generation)** - 讓大型語言模型能參考外部知識庫來回答問題。
*   代表：Faiss (Facebook 開源)、Annoy (Spotify 開源)、HNSW (演算法)、Pinecone, Weaviate (專用雲端服務)

## 選型考量 Checklist

1.  **資料模型 & 關聯複雜度**：你的資料長什麼樣子？是結構化的表格，還是彈性的文件，或是複雜的關係圖？
2.  **讀寫比例 (Read/Write Ratio)**：系統是讀取多還是寫入多？例如，新聞網站讀取遠大於寫入，而 IoT 感測器數據則是寫入遠大於讀取。
3.  **一致性 vs 可用性 (CAP 定理的取捨)**：你比較能容忍系統短暫不回應 (低可用性但強一致)，還是能容忍資料暫時有點小差異 (高可用性但最終一致)？
4.  **擴展策略 (Vertical / Horizontal Scaling)**：
    *   Vertical Scaling (垂直擴展)：買更好的機器 (更強的 CPU、更多 RAM)。有極限，且貴。
    *   Horizontal Scaling (水平擴展)：買更多普通機器來分攤工作。NoSQL 資料庫通常更容易水平擴展。
5.  **團隊熟悉度 & 生態系**：團隊成員對哪種資料庫比較熟悉？社群支援、工具、文件是否完善？
6.  **成本、合規、安全需求**：開源還是商業？雲端託管還是自建？是否有特殊的資料保護法規要遵守？
7.  **專用功能**：是否需要全文檢索、地理空間查詢 (GIS)、圖遍歷、時間序列分析、向量搜尋等特殊功能？

<Callout type="info">
### 給初學者的選型建議
專案初期，若無特殊需求，優先選擇團隊熟悉的關聯式資料庫 (如 PostgreSQL 或 MySQL)。待需求明確或遇到瓶頸時，再考慮引入 NoSQL 資料庫或其他專用資料庫。切忌盲目追求新技術，解決問題才是根本。
</Callout>

> **給同學的建議**：剛開始做專案時，如果沒有特殊需求，選擇一個你和團隊最熟悉的關聯式資料庫 (如 PostgreSQL 或 MySQL) 通常是個不錯的起點。隨著需求變複雜，再考慮引入其他類型的資料庫來輔助。不要一開始就想用最新最潮的技術，除非它真的能解決你的核心問題！ 