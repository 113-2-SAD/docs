---
title: Discord 資料庫演進案例研究
description: 從 Discord 擴展其資料庫基礎設施以應對大規模增長的歷程中學習。
icon: BookOpen
---

> 這是一個關於 Discord 如何從一個小小的聊天應用，成長為擁有數億用戶的巨型平台，以及他們的資料庫是如何一步步跟上這個瘋狂成長的故事。這不只是一個技術故事，更是一個關於「遇到問題、分析問題、解決問題」的實戰經驗分享！

<Callout type="info">
### 案例核心
本案例追蹤 Discord 在用戶爆發性增長下，其資料庫架構如何從 MongoDB 演進到 Cassandra，最終到 ScyllaDB，並輔以多種優化手段，以應對極端規模的即時通訊需求。
</Callout>

## 背景與挑戰 (大約 2015-2016 年)

*   **用戶爆炸性增長**：Discord 推出後，因為其低延遲語音、遊戲社群的特性，用戶量像火箭一樣往上衝。原本可能一天幾萬條訊息，很快就變成幾百萬、幾千萬甚至上億條訊息！
*   **MongoDB 撐不住了**：他們一開始選用的是 MongoDB (一個文件型 NoSQL 資料庫)。初期可能還好，但隨著用戶和訊息量暴增，問題開始浮現：
    *   **寫入速度變慢 (Write Contention)**：想像一下，只有一個小小的郵筒 (MongoDB 的單一主節點或寫入瓶頸)，但突然有成千上萬的人同時要寄信（寫入新訊息），郵筒很快就被塞爆了，大家都要排隊等很久。
    *   **延遲變高 (Latency)**：因為寫入變慢、查詢也可能變慢，使用者發送或接收訊息就會感覺到「卡卡的」、「轉圈圈」。
    *   **擴展性問題**：雖然 MongoDB 也可以做分片 (Sharding)，但在當時 Discord 的特定使用情境和資料模型下，可能遇到了擴展瓶頸，或者擴展後的管理複雜度變高。
*   **核心需求：即時聊天不卡頓**：對 Discord 這種即時通訊軟體來說，訊息的低延遲是生命線。沒有人喜歡發一條訊息要等好幾秒才送出去。

<Callout type="info">
### 初期挑戰：MongoDB 的瓶頸
Discord 初期使用 MongoDB，但隨著用戶量和訊息量激增，面臨寫入速度變慢、延遲升高和擴展性問題，嚴重影響核心的即時聊天體驗。
</Callout>

> **給同學的思考**：如果你是當時 Discord 的工程師，面對每天都在翻倍的訊息量，你會怎麼辦？繼續優化現有的 MongoDB，還是考慮換一個全新的資料庫？這是一個很大的抉擇！

## 階段一：勇敢轉舵 — 改用 Cassandra (NoSQL 列式資料庫)

*   **為什麼要換？** Cassandra 以其優異的「水平擴展性」和「高寫入吞吐量」聞名。這正是 Discord 當下最需要的！
    *   **水平擴展**：Cassandra 設計上就是分散式的，可以輕易地增加更多普通伺服器來分攤負載，理論上可以無限擴展。
    *   **高寫入吞吐**：Cassandra 的寫入路徑經過優化，非常適合大量寫入的場景（例如每秒幾十萬筆訊息）。
*   **怎麼做？ — 以「伺服器 ID (Guild ID) / 頻道 ID (Channel ID)」來分片 (Sharding)**：
    *   **核心思想**：把同一個 Discord 伺服器 (Guild) 或同一個頻道 (Channel) 的訊息，盡可能地放在同一組 Cassandra 節點上，或是透過 Guild ID/Channel ID 做為分片鍵 (Partition Key)。
    *   **打個比方**：想像一個超大的辦公大樓 (整個 Discord)，每個公司 (Guild) 有自己的辦公室 (Cassandra 節點/分片)。當 A 公司的員工要找 B 公司的文件，系統就知道要去 B 公司的辦公室找，而不是搜遍整棟大樓。
    *   這樣做的好處是，大部分的讀取操作（例如載入某個頻道的歷史訊息）可以被導向到特定的分片，提高查詢效率。
*   **新問題浮現**：
    *   **讀取變慢了**：雖然 Cassandra 寫入很快，但某些複雜的讀取模式（例如：查詢某個使用者在「所有」伺服器發送過的訊息）可能會比較慢。因為 Cassandra 的資料模型不像關聯式資料庫那樣支持任意的 JOIN 操作，有時需要應用程式層做更多工作，或者資料會為了寫入優化而做一些「反規範化 (Denormalization)」，導致讀取時需要讀取更多不必要的資料，或者從多個地方讀取再聚合。
    *   **資料一致性模型不同**：Cassandra 預設提供的是「最終一致性 (Eventual Consistency)」。這表示當你寫入一條新訊息，它可能不會馬上出現在所有副本上，需要一點點時間同步。對聊天應用來說，大部分時候可以接受，但某些情況下可能需要更強的一致性保證，這就需要調整設定或在應用程式層處理。

<Callout type="info">
### 轉向 Cassandra：追求寫入與擴展
為解決 MongoDB 的瓶頸，Discord 選擇了以**高寫入吞吐和水平擴展性**著稱的 Cassandra。透過 Guild ID/Channel ID 進行分片，有效分散了寫入壓力。但同時也帶來了讀取效能和資料一致性模型的新挑戰。
</Callout>

## 階段二：追求極致 — 再換 ScyllaDB (Cassandra 的 C++ 高效能版)

*   **為什麼又要換？** Cassandra 是用 Java 寫的。Java 有一個東西叫做「垃圾回收 (Garbage Collection, GC)」。
    *   **GC 的困擾**：當 Java 程式運行時，會產生很多不再使用的記憶體物件（垃圾）。GC 會定期或在記憶體不足時啟動，把這些垃圾清掉，釋放記憶體。但在 GC 運行的期間，有時會導致應用程式短暫停頓 (Stop-The-World Pause)。對於像 Discord 這樣對延遲極度敏感的系統，即使是幾十到幾百毫秒的 GC 停頓，都可能讓使用者感覺到卡頓。
*   **ScyllaDB — Cassandra 的超級賽亞人版**：
    *   ScyllaDB 號稱是 Cassandra 的 C++ 重寫版本，API 介面與 Cassandra 相容（所以 Discord 遷移過去的程式碼改動不大）。
    *   **C++ 的優勢 (在這裡)**：C++ 讓開發者能更精細地控制記憶體管理，可以避免像 Java GC 那樣不可預測的長時間停頓。ScyllaDB 內部也針對現代多核心 CPU 和高速 NVMe SSD 做了大量優化。
*   **驚人的好處**：
    *   **延遲大幅降低**：據 Discord 分享，遷移到 ScyllaDB 後，P99 延遲 (99% 的請求都能在此時間內完成) 降低了 5-10 倍！這對使用者體驗是巨大的提升。
    *   **伺服器數量減半以上**：因為 ScyllaDB 的效能更好，同樣的負載下，需要的伺服器數量比 Cassandra 少了一半以上。
    *   **硬體成本節省**：更少的伺服器意味著更低的硬體採購成本和維運成本，省了超過 30%！

<Callout type="info">
### 再遷 ScyllaDB：克服 GC，提升效能
Cassandra 的 Java GC 停頓影響了 Discord 的低延遲需求。因此，他們遷移到 C++ 重寫、API 相容的 ScyllaDB，大幅**降低了 P99 延遲、減少了伺服器數量並節省了成本**，實現了顯著的效能提升。
</Callout>

> **給同學的啟示**：即使選擇了某個技術方向 (例如 Cassandra)，也不代表就一勞永逸了。持續關注技術的演進，尋找更優的解決方案，是優秀工程師的特質。ScyllaDB 就是一個「站在巨人肩膀上」並做得更好的例子。

## 其他重要的優化方法 (不只是換資料庫！)

換資料庫是大手術，但 Discord 的擴展之路還做了很多其他聰明的優化：

*   **用 Redis 存熱點資料和狀態**：Redis 是一個超高速的記憶體鍵值資料庫。
    *   **範例**：
        *   **誰在線上 (Presence)**：一個伺服器裡有哪些用戶目前在線？這些狀態變化非常頻繁，適合放 Redis。
        *   **使用者 Session**：使用者登入後的會話資訊。
        *   **快取常用資料**：例如 Discord 伺服器的設定、頻道列表等不常變動但讀取頻繁的資訊。
    *   **好處**：極快的回應速度，並大幅減輕主要資料庫 (ScyllaDB) 的壓力。
*   **用 Rust 寫高效能中間層 (Middleware)**：
    *   **這是什麼？** 在應用程式和資料庫之間加一層服務，專門處理資料的讀寫、路由、快取等邏輯。
    *   **為什麼用 Rust？** Rust 語言以其高效能和記憶體安全著稱，沒有 GC 停頓問題，非常適合做這種對效能要求極高的基礎服務。
    *   **功能**：
        *   **統一管理資料流向**：決定哪些請求讀快取，哪些請求讀資料庫。
        *   **聰明地分散負載 (Load Balancing)**：將請求均勻地導向到後端的 ScyllaDB 叢集。
        *   **API Gateway 的部分功能**：可能還負責一些請求的驗證、格式轉換等。
    *   **生活化比喻**：這個 Rust 中間層就像一個機場的「超級塔台」，精準地指揮每一架飛機 (資料請求) 該去哪個跑道 (資料庫節點/快取)，確保機場運作順暢高效。
*   **大量使用快取 (Caching is King!)**：前面提過的，不只是 Redis，可能在應用程式內部、CDN 等多個層級都有快取機制。
    *   **原則**：任何可以快取的東西，都盡量快取。目標是「盡可能讓請求不要打到資料庫」。
*   **批次寫入 (Batch Writes)**：
    *   **這是什麼？** 與其一有新資料就馬上寫入資料庫（例如，使用者每按一個讚就寫一次），不如先在應用程式記憶體中累積一小批資料（例如，累積 100 個讚或等 1 秒鐘），然後一次性批量寫入資料庫。
    *   **好處**：減少對資料庫的即時寫入壓力，提升整體寫入吞吐量。因為每次寫入操作都有固定開銷，批量寫入可以攤平這個開銷。
    *   **注意**：需要權衡即時性和批次大小/頻率。批次太大或太頻繁，效果可能不好；批次太小或間隔太長，使用者可能會感覺到延遲。

<Callout type="info">
### 多管齊下的優化策略
除了核心資料庫的選型，Discord 還綜合運用了多種優化手段：
- **Redis 快取**：儲存熱点資料 (如在線狀態、Session) 以加速讀取並減輕主資料庫壓力。
- **Rust 中間層**：高效能地管理資料流、負載均衡。
- **廣泛快取 (Caching is King)**：在多層級實施快取，最小化資料庫訪問。
- **批次寫入**：聚合少量寫入操作，提升整體寫入吞吐。
</Callout>

## 從 Discord 身上學到的寶貴經驗

1.  **不同資料庫各司其職 (Polyglot Persistence)**：沒有萬能的資料庫。針對不同的資料特性和存取需求，選擇最適合的組合。Discord 就用了 ScyllaDB (核心訊息儲存) + Redis (快取/狀態) + 可能還有其他用於分析或搜尋的資料庫。
    *   **給同學**：不要陷入「SQL vs NoSQL 哪個比較好」的迷思，它們是合作夥伴，不是敵人。
2.  **慢慢改，持續監控 (Iterative Approach & Monitoring)**：更換核心資料庫是大工程，風險很高。通常會採用逐步遷移、灰度發布（先讓一小部分用戶使用新系統）的方式，並且在過程中密切監控各項指標 (延遲、錯誤率、資源使用率)，確保一切穩定。
    *   **給同學**：做任何系統變更，都要有數據支撐，並且準備好「回滾計畫」。
3.  **自己寫工具補強 (Build Your Own Tools When Necessary)**：有時現成的工具不完全符合需求，或者為了達到極致效能，需要自己動手打造一些客製化的解決方案，例如 Discord 的 Rust 中間層。
    *   **給同學**：先學會用好現有工具，當你真正理解其瓶頸時，再考慮造輪子。
4.  **持續優化 (Continuous Optimization)**：系統擴展是永無止境的。隨著用戶量增長、功能迭代，新的瓶頸會不斷出現。保持學習，不斷測試、分析、優化，是大型系統維運的常態。

<Callout type="info">
### Discord 案例的啟示
1.  **混合持久化 (Polyglot Persistence)**：依需求組合不同資料庫。
2.  **迭代與監控**：逐步遷移，密切監控，準備回滾。
3.  **自研工具**：必要時打造客製化方案以達極致效能。
4.  **持續優化**：系統擴展是個持續演進的過程。
</Callout>

> **總結**：Discord 的故事告訴我們，成功的系統架構不是一蹴可幾的，而是不斷演進、不斷試錯、不斷學習的結果。他們對技術的深入理解、對效能的極致追求，以及解決問題的勇氣和智慧，都值得我們學習！ 